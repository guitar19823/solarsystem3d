
--- Файл: src/adapters/browser-adapter.ts ---
import { PlatformAdapter } from "./platform-adapter";

export class BrowserAdapter implements PlatformAdapter {
  private resizeCallbacks: Set<() => void> = new Set();
  private canvas: HTMLCanvasElement | undefined;

  constructor() {
    this.canvas = document.createElement("canvas");

    document.body.appendChild(this.canvas);
  }

  getMainCanvas(): HTMLCanvasElement | undefined {
    return this.canvas;
  }

  getCanvas(): HTMLCanvasElement | undefined {
    return document.createElement("canvas");
  }

  getWidth(): number {
    return Math.max(window.innerWidth, 400); // мин. ширина 400px
  }

  getHeight(): number {
    return Math.max(window.innerHeight, 300); // мин. высота 300px
  }

  getPixelRatio(): number {
    return window.devicePixelRatio;
  }

  onResize(callback: () => void): void {
    this.resizeCallbacks.add(callback);
    window.addEventListener("resize", callback);
  }

  offResize(callback: () => void): void {
    this.resizeCallbacks.delete(callback);
    window.removeEventListener("resize", callback);
  }

  appendToDom(element: HTMLElement): void {
    document.body.appendChild(element);
  }

  appendCanvasToDom(): void {
    if (this.canvas) {
      document.body.appendChild(this.canvas);
    }
  }

  requestAnimationFrame(callback: FrameRequestCallback): void {
    window.requestAnimationFrame(callback);
  }

  onZoom(callback: (value: number) => void): void {
    window.addEventListener("wheel", (e) => {
      callback(e.deltaY);
    });
  }

  onPress(callback: (value: string) => void): void {
    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyW") callback("forward");
      if (e.code === "KeyS") callback("back");
      if (e.code === "KeyA") callback("left");
      if (e.code === "KeyD") callback("right");
      if (e.code === "KeyQ") callback("up");
      if (e.code === "KeyE") callback("down");
    });
  }

  onRelease(callback: (value: string) => void): void {
    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyW") callback("forward");
      if (e.code === "KeyS") callback("back");
      if (e.code === "KeyA") callback("left");
      if (e.code === "KeyD") callback("right");
      if (e.code === "KeyQ") callback("up");
      if (e.code === "KeyE") callback("down");
    });
  }

  onMove(callback: (x: number, y: number) => void): void {
    this.canvas?.addEventListener("mousemove", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onMoveStart(callback: (x: number, y: number) => void): void {
    this.canvas?.addEventListener("mousedown", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onMoveEnd(callback: (x: number, y: number) => void): void {
    this.canvas?.addEventListener("mouseup", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onLeave(callback: (x: number, y: number) => void): void {
    this.canvas?.addEventListener("mouseleave", (e) => {
      callback(e.clientX, e.clientY);
    });
  }
}

--------------------------------------------------

--- Файл: src/adapters/platform-adapter.ts ---
export interface PlatformAdapter {
  getMainCanvas(): HTMLCanvasElement | undefined;
  getCanvas(): HTMLCanvasElement | undefined;
  getWidth(): number;
  getHeight(): number;
  getPixelRatio(): number;
  onResize(callback: () => void): void;
  offResize(callback: () => void): void;
  appendToDom(element: HTMLElement): void;
  appendCanvasToDom(): void;
  requestAnimationFrame(callback: FrameRequestCallback): void;
  onZoom(callback: (value: number) => void): void;
  onPress(callback: (value: string) => void): void;
  onRelease(callback: (value: string) => void): void;
  onMove(callback: (x: number, y: number) => void): void;
  onMoveStart(callback: (x: number, y: number) => void): void;
  onMoveEnd(callback: (x: number, y: number) => void): void;
  onLeave(callback: (x: number, y: number) => void): void;
}

--------------------------------------------------

--- Файл: src/config/config-api.ts ---
import { Vector3D } from "../physics/vector";
import { SPACE_OBJECTS, ISpaceObjectConfig } from "./space-objects";
import { SIMULATION_CONFIG } from "./simulation-config";

export interface SimulationConfig {
  SIMULATION_DT: number;
  DEFAULT_DT: number;
  MAX_DT: number;
  AU_IN_PX: number;
  OBJECTS_RADIUS_SCALE: number;
}

export class ConfigAPI {
  private static spaceObjects: ISpaceObjectConfig[] = [...SPACE_OBJECTS]; // изначальные данные

  static setSimulationSpeed(factor: number): void {
    if (factor <= 0) {
      throw new Error("Simulation speed factor must be positive");
    }
    SIMULATION_CONFIG.SIMULATION_DT = factor;
  }

  static getSimulationSpeed(): number {
    return SIMULATION_CONFIG.SIMULATION_DT;
  }

  static setScale(auInPx: number): void {
    if (auInPx <= 0) {
      throw new Error("AU in pixels must be positive");
    }
    SIMULATION_CONFIG.AU_IN_PX = auInPx;
  }

  static getScale(): number {
    return SIMULATION_CONFIG.AU_IN_PX;
  }

  static setSpaceObjectScale(scale: number): void {
    if (scale <= 0) {
      throw new Error("SpaceObject radius scale must be positive");
    }
    SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE = scale;
  }

  static getSpaceObjectScale(): number {
    return SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE;
  }

  static getLabelScaleFactor(): number {
    return SIMULATION_CONFIG.LABEL_SCALE_FATOR;
  }

  static setLabelScaleFactor(factor: number): void {
    if (factor <= 0) {
      throw new Error("Label scale factor must be positive");
    }
    SIMULATION_CONFIG.LABEL_SCALE_FATOR = factor;
  }

  static getSpeedFactor(): number {
    return SIMULATION_CONFIG.SPEED_FACTOR * 10000000;
  }

  static setSpeedFactor(factor: number): void {
    if (factor <= 0) {
      throw new Error("Label scale factor must be positive");
    }
    SIMULATION_CONFIG.SPEED_FACTOR = factor / 10000000;
  }

  static addSpaceObject(config: ISpaceObjectConfig): void {
    const existing = ConfigAPI.getSpaceObject(config.name);
    if (existing) {
      throw new Error(`SpaceObject with name "${config.name}" already exists`);
    }
    ConfigAPI.spaceObjects.push(config);
  }

  static removeSpaceObject(name: string): boolean {
    const index = ConfigAPI.findSpaceObjectIndex(name);
    if (index === -1) {
      return false;
    }
    ConfigAPI.spaceObjects.splice(index, 1);
    return true;
  }

  static updateSpaceObject(
    name: string,
    updates: Partial<ISpaceObjectConfig>
  ): boolean {
    const spaceObject = ConfigAPI.getSpaceObject(name);
    if (!spaceObject) {
      return false;
    }

    Object.assign(spaceObject, updates);
    return true;
  }

  static getSpaceObject(name: string): ISpaceObjectConfig | undefined {
    return ConfigAPI.spaceObjects.find((p) => p.name === name);
  }

  static getAllSpaceObjects(): ISpaceObjectConfig[] {
    return [...ConfigAPI.spaceObjects]; // возвращаем копию
  }

  private static findSpaceObjectIndex(name: string): number {
    return ConfigAPI.spaceObjects.findIndex((p) => p.name === name);
  }

  static resetSimulationConfig(): void {
    SIMULATION_CONFIG.SIMULATION_DT = 1;
    SIMULATION_CONFIG.DEFAULT_DT = 86400;
    SIMULATION_CONFIG.MAX_DT = 864000;
    SIMULATION_CONFIG.AU_IN_PX = 100;
    SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE = 1;
  }

  static resetSpaceObjectData(): void {
    ConfigAPI.spaceObjects = [
      {
        name: "Sun",
        mass: 1.989e30,
        pos: new Vector3D(0, 0, 0),
        vel: new Vector3D(0, 0, 0),
        color: "yellow",
        radius: 696340000,
      },
      // ... остальные планеты как в исходном SPACE_OBJECTS
    ];
  }
}

--------------------------------------------------

--- Файл: src/config/simulation-config.ts ---
export const SIMULATION_CONFIG = {
  SIMULATION_DT: 1, // шаг симуляции (x реального времени)
  DEFAULT_DT: 86400,
  MAX_DT: 864000, // макс. шаг симуляции (защита от фризов)

  AU_IN_PX: 500, // Сколько пикселей соответствует 1 а.е. (настраивается пользователем)
  AU: 1.496e11, // 1 а.е. = 1.496e11 м

  OBJECTS_RADIUS_SCALE: 1, // Коэффициент для увеличения радиусов планет (по умолчанию = 1 — строго пропорционально)
  LABEL_SCALE_FATOR: 5,
  SPEED_FACTOR: 0.0000001,

  // Масштаб для расстояний: 1 м = ? px
  get SCALE_DIST() {
    return this.AU_IN_PX / this.AU;
  },
};

--------------------------------------------------

--- Файл: src/config/space-objects.ts ---
import { Vector3D } from "../physics/vector";

export interface ISpaceObjectConfig {
  name: string;
  mass: number;
  pos: Vector3D;
  vel: Vector3D;
  color: string;
  radius: number; // в метрах
  texture?: string;
}

export const SPACE_OBJECTS: ISpaceObjectConfig[] = [
  {
    name: "Sun",
    mass: 1.989e30,
    pos: new Vector3D(0, 0, 0),
    vel: new Vector3D(0, 0, -0),
    color: "white",
    radius: 696340000,
  },
  {
    name: "Mercury",
    mass: 3.3011e23,
    pos: new Vector3D(5.791e10, 0, 0),
    vel: new Vector3D(0, 0, -47362),
    color: "gray",
    radius: 2439700,
    texture: "mercuryhigh-min.jpg",
  },
  {
    name: "Venus",
    mass: 4.8675e24,
    pos: new Vector3D(1.082e11, 0, 0),
    vel: new Vector3D(0, 0, -35020),
    color: "orange",
    radius: 6051800,
    texture: "venushigh-min.jpg",
  },
  {
    name: "Earth",
    mass: 5.972e24,
    pos: new Vector3D(1.496e11, 0, 0),
    vel: new Vector3D(0, 0, -29783),
    color: "blue",
    radius: 6371000,
    texture: "earthhigh-min.jpg",
  },
  {
    name: "Mars",
    mass: 6.4171e23,
    pos: new Vector3D(2.279e11, 0, 0),
    vel: new Vector3D(0, 0, -24077),
    color: "red",
    radius: 3389500,
    texture: "marshigh-min.jpg",
  },
  {
    name: "Jupiter",
    mass: 1.8982e27,
    pos: new Vector3D(7.785e11, 0, 0),
    vel: new Vector3D(0, 0, -13070),
    color: "brown",
    radius: 69911000,
    texture: "jupiterhigh-min.jpg",
  },
  {
    name: "Saturn",
    mass: 5.6834e26,
    pos: new Vector3D(1.434e12, 0, 0),
    vel: new Vector3D(0, 0, -9690),
    color: "gold",
    radius: 58232000,
    texture: "saturnhigh-min.jpg",
  },
  {
    name: "Uranus",
    mass: 8.681e25,
    pos: new Vector3D(2.871e12, 0, 0),
    vel: new Vector3D(0, 0, -6810),
    color: "lightblue",
    radius: 25362000,
    texture: "uranushigh-min.jpg",
  },
  {
    name: "Neptune",
    mass: 1.0241e26,
    pos: new Vector3D(4.495e12, 0, 0),
    vel: new Vector3D(0, 0, -5430),
    color: "darkblue",
    radius: 24622000,
    texture: "neptunehigh-min.jpg",
  },
];

--------------------------------------------------

--- Файл: src/entities/celestial-body.ts ---
import { Vector3D } from "../physics/vector";
import { ISpaceObject } from "./interface";

export abstract class CelestialBody implements ISpaceObject {
  constructor(
    public name: string,
    public mass: number,
    public pos: Vector3D,
    public vel: Vector3D,
    public color: string,
    public radius: number,
    public texture: string | undefined
  ) {}

  abstract update(dt: number, others: ISpaceObject[]): void;
}

--------------------------------------------------

--- Файл: src/entities/interface.ts ---
import { Vector3D } from "../physics/vector";

export interface ISpaceObject {
  name: string;
  mass: number;
  pos: Vector3D;
  vel: Vector3D;
  color: string;
  radius: number; // в метрах
  texture?: string;
}

--------------------------------------------------

--- Файл: src/entities/space-object.ts ---
import { CelestialBody } from "./celestial-body";
import { GravityCalculator } from "../physics/gravity";

export class SpaceObject extends CelestialBody {
  update(dt: number, others: SpaceObject[]) {
    // Метод (Эйлер)
    // const acc = GravityCalculator.calculateAcceleration(this, others);
    // this.vel = this.vel.add(acc.multiply(dt));
    // this.pos = this.pos.add(this.vel.multiply(dt));

    // Метод (Верле)
    const posOld = this.pos;
    const acc = GravityCalculator.calculateAcceleration(this, others);

    this.pos = posOld
      .add(this.vel.multiply(dt))
      .add(acc.multiply(0.5 * dt * dt));

    const accNew = GravityCalculator.calculateAcceleration(this, others);
    this.vel = this.vel.add(acc.add(accNew).multiply(0.5 * dt));
  }
}

--------------------------------------------------

--- Файл: src/main.ts ---
import * as THREE from "three";
import { PlatformAdapter } from "./adapters/platform-adapter";
import { BrowserAdapter } from "./adapters/browser-adapter";
import { SolarSystem } from "./simulation/solar-system";
import { SIMULATION_CONFIG } from "./config/simulation-config";
import { ConfigAPI } from "./config/config-api";

import { SceneManager } from "./rendering/scene-manager";
import { CameraController } from "./rendering/camera-controller";
import { TextureManager } from "./rendering/texture-manager";
import { ObjectFactory } from "./rendering/object-factory";
import { RendererCore } from "./rendering/renderer-core";

export function runSimulation(platformAdapter: PlatformAdapter) {
  const sceneManager = new SceneManager();
  const textureManager = new TextureManager();
  const objectFactory = new ObjectFactory(textureManager);
  const cameraController = new CameraController(platformAdapter);

  const renderer = new RendererCore(
    platformAdapter,
    sceneManager,
    cameraController,
    objectFactory
  );

  renderer.initialize();

  const fpsElement = document.createElement("div");
  fpsElement.style.position = "absolute";
  fpsElement.style.top = "10px";
  fpsElement.style.right = "10px";
  fpsElement.style.color = "lime";
  document.body.appendChild(fpsElement);
  renderer.setFpsElement(fpsElement);

  const system = new SolarSystem(SIMULATION_CONFIG.MAX_DT);

  renderer.initSpaceObjects(system.getSpaceObjects());

  let lastTimestamp = 0;

  function animate(currentTimestamp: number) {
    const deltaTime = currentTimestamp - lastTimestamp;
    lastTimestamp = currentTimestamp;

    const simulationTimeStep = Math.min(
      (deltaTime / 1000) * SIMULATION_CONFIG.SIMULATION_DT,
      SIMULATION_CONFIG.MAX_DT
    );

    system.step(simulationTimeStep);
    renderer.updateSpaceObjects(system.getSpaceObjects());
    renderer.render(deltaTime);

    platformAdapter.requestAnimationFrame(animate);
  }

  platformAdapter.requestAnimationFrame(animate);

  platformAdapter.onResize(() => {
    renderer.initialize();
  });
}

function initControls() {
  const speedSlider = document.getElementById(
    "speed-slider"
  ) as HTMLInputElement;
  const speedValue = document.getElementById("speed-value");

  if (speedValue) {
    const getSimulationSpeed = ConfigAPI.getSimulationSpeed();
    speedSlider.value = getSimulationSpeed.toString();
    speedValue.textContent = getSimulationSpeed.toString();

    speedSlider.addEventListener("input", () => {
      const value = parseInt(speedSlider.value, 10);
      ConfigAPI.setSimulationSpeed(value);
      speedValue.textContent = value.toString();
    });
  }

  // Управление масштабом меток (labelScaleFactor)
  const labelScaleSlider = document.getElementById(
    "label-scale-slider"
  ) as HTMLInputElement;
  const labelScaleValue = document.getElementById("label-scale-value");

  if (labelScaleSlider && labelScaleValue) {
    const labelScaleFactor = ConfigAPI.getLabelScaleFactor().toString();
    labelScaleSlider.value = labelScaleFactor;
    labelScaleValue.textContent = labelScaleFactor;

    labelScaleSlider.addEventListener("input", () => {
      const value = parseFloat(labelScaleSlider.value);
      ConfigAPI.setLabelScaleFactor(value);
      labelScaleValue.textContent = value.toString();
    });
  }

  // Управление speedFactor (дополнительный множитель скорости)
  const speedFactorSlider = document.getElementById(
    "speed-factor-slider"
  ) as HTMLInputElement;
  const speedFactorValue = document.getElementById("speed-factor-value");

  if (speedFactorSlider && speedFactorValue) {
    const speedFactor = ConfigAPI.getSpeedFactor().toString();
    speedFactorSlider.value = speedFactor;
    speedFactorValue.textContent = speedFactor;

    speedFactorSlider.addEventListener("input", () => {
      const value = parseFloat(speedFactorSlider.value);
      ConfigAPI.setSpeedFactor(value);
      speedFactorValue.textContent = value.toString();
    });
  }
}

const platformAdapter = new BrowserAdapter();
runSimulation(platformAdapter);
initControls();

--------------------------------------------------

--- Файл: src/physics/gravity.ts ---
import { SpaceObject } from "../entities/space-object";
import { Vector3D } from "./vector";

export class GravityCalculator {
  static readonly G = 6.6743e-11; // м³·кг⁻¹·с⁻²

  static calculateAcceleration(
    spaceObject: SpaceObject,
    others: SpaceObject[]
  ): Vector3D {
    let acc = new Vector3D();

    for (const other of others) {
      if (other === spaceObject) continue;

      const dx = other.pos.x - spaceObject.pos.x;
      const dy = other.pos.y - spaceObject.pos.y;
      const dz = other.pos.z - spaceObject.pos.z;
      const distSq = dx * dx + dy * dy + dz * dz;

      if (distSq < 1e-20) continue;

      const dist = Math.sqrt(distSq);
      const minDist = spaceObject.radius + other.radius;

      if (dist < minDist) {
        console.warn(`Столкновение: ${spaceObject.name} и ${other.name}`);
        continue;
      }

      const forceFactor = (this.G * other.mass) / (dist * distSq);

      acc = acc.add(
        new Vector3D(forceFactor * dx, forceFactor * dy, forceFactor * dz)
      );
    }

    return acc;
  }
}

--------------------------------------------------

--- Файл: src/physics/vector.ts ---
export interface Vector {
  x: number;
  y: number;
  z: number;
}

export class Vector3D implements Vector {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  add(v: Vector3D): Vector3D {
    return new Vector3D(this.x + v.x, this.y + v.y, this.z + v.z);
  }

  multiply(scalar: number): Vector3D {
    return new Vector3D(this.x * scalar, this.y * scalar, this.z * scalar);
  }

  magnitude(): number {
    return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);
  }
}

--------------------------------------------------

--- Файл: src/rendering/camera-controller.ts ---
import * as THREE from "three";
import { ICameraController } from "./interfaces";
import { PlatformAdapter } from "../adapters/platform-adapter";
import { SIMULATION_CONFIG } from "../config/simulation-config";

export class CameraController implements ICameraController {
  private camera: THREE.PerspectiveCamera;

  private yaw: number = 0;
  private pitch: number = 0;

  private target: THREE.Vector3 = new THREE.Vector3(0, 0, 0);

  private damping: number = 0.25;
  private velocity: THREE.Vector2 = new THREE.Vector2(0, 0);

  private commands = new Set();
  private moveSpeed: number = 500;

  private isMouseDown: boolean = false;
  private mousePrev: THREE.Vector2 = new THREE.Vector2();
  private mouseCurr: THREE.Vector2 = new THREE.Vector2();

  constructor(platformAdapter: PlatformAdapter) {
    this.camera = new THREE.PerspectiveCamera(
      65,
      platformAdapter.getWidth() / platformAdapter.getHeight(),
      0.001,
      50000000000
    );

    this.setupEvents(platformAdapter);
    this.updateCamera();
  }

  private setupEvents(platformAdapter: PlatformAdapter): void {
    platformAdapter.onMoveStart((x, y) => {
      this.isMouseDown = true;
      this.mousePrev.set(x, y);
    });

    platformAdapter.onMoveEnd(() => {
      this.isMouseDown = false;
    });

    platformAdapter.onLeave(() => {
      this.isMouseDown = false;
    });

    platformAdapter.onMove((x, y) => {
      if (this.isMouseDown) {
        this.mouseCurr.set(x, y);
        this.handleMouseRotate();
        this.mousePrev.copy(this.mouseCurr);
      }
    });

    platformAdapter.onZoom((value) => {
      const zoomSpeed = 10;
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(this.camera.quaternion);
      this.target.addScaledVector(direction, value * 0.01 * zoomSpeed);
      this.updateCamera();
    });

    platformAdapter.onPress((value) => {
      this.commands.add(value);
    });

    platformAdapter.onRelease((value) => {
      this.commands.delete(value);
    });
  }

  update(): void {
    this.applyDamping();
    this.updateCameraPosition();
    this.updateCamera();
  }

  private applyDamping(): void {
    this.velocity.multiplyScalar(1 - this.damping);
  }

  private handleMouseRotate(): void {
    const delta = new THREE.Vector2()
      .subVectors(this.mouseCurr, this.mousePrev)
      .multiplyScalar(0.002);

    this.velocity.set(-delta.x, delta.y);
  }

  private updateCameraPosition(): void {
    if (!this.commands.size) return;

    const move = new THREE.Vector3();

    const cameraDirection = new THREE.Vector3(0, 0, -1);
    cameraDirection.applyQuaternion(this.camera.quaternion);

    const right = new THREE.Vector3(1, 0, 0);
    right.applyQuaternion(this.camera.quaternion);

    const up = new THREE.Vector3(0, 1, 0);

    let dx = 0,
      dy = 0,
      dz = 0;

    if (this.commands.has("forward")) dz += 1;
    if (this.commands.has("back")) dz -= 1;
    if (this.commands.has("left")) dx -= 1;
    if (this.commands.has("right")) dx += 1;
    if (this.commands.has("up")) dy += 1;
    if (this.commands.has("down")) dy -= 1;

    if (dx !== 0 || dy !== 0 || dz !== 0) {
      move
        .addScaledVector(right, dx)
        .addScaledVector(up, dy)
        .addScaledVector(cameraDirection, dz);

      move.multiplyScalar(this.moveSpeed * SIMULATION_CONFIG.SPEED_FACTOR);

      this.camera.position.add(move);
      this.target.add(move);
    }
  }

  private updateCamera(): void {
    this.yaw += this.velocity.x;
    this.pitch += this.velocity.y;

    this.pitch = Math.max(
      -Math.PI / 2 + 0.01,
      Math.min(Math.PI / 2 - 0.01, this.pitch)
    );

    this.velocity.set(0, 0);

    const rotationMatrix = new THREE.Matrix4();
    const pitchMatrix = new THREE.Matrix4();

    rotationMatrix.makeRotationY(this.yaw);
    pitchMatrix.makeRotationX(this.pitch);
    rotationMatrix.multiply(pitchMatrix);

    this.camera.quaternion.setFromRotationMatrix(rotationMatrix);
    this.camera.position.copy(this.target);

    this.camera.lookAt(
      this.target
        .clone()
        .add(new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix))
    );
  }

  resize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
  }

  getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  lookAt(target: THREE.Vector3): void {
    this.target.copy(target);
    this.updateCamera();
  }

  setPosition(position: THREE.Vector3): void {
    this.camera.position.copy(position);
    this.target.copy(position);
    this.updateCamera();
  }

  reset(): void {
    this.yaw = 0;
    this.pitch = 0;
    this.target.set(0, 0, 0);
    this.velocity.set(0, 0);
    this.updateCamera();
  }

  setEnabled(enabled: boolean): void {}

  getPosition(): THREE.Vector3 {
    return this.camera.position;
  }

  getDirection(): THREE.Vector3 {
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    return direction;
  }
}

--------------------------------------------------

--- Файл: src/rendering/interfaces.ts ---
import * as THREE from "three";
import { SpaceObject } from "../entities/space-object";
import { PlatformAdapter } from "../adapters/platform-adapter";

export interface ITextureManager {
  loadTexture(path: string): THREE.Texture;
}

export interface IObjectFactory {
  createSpaceObject(spaceObject: SpaceObject): THREE.Mesh;
  createSpaceBackground(): THREE.Mesh;
  createLabelSprite(
    text: string,
    platformAdapter: PlatformAdapter
  ): THREE.Sprite | undefined;
}

export interface ISceneManager {
  getScene(): THREE.Scene;
  setupLighting(): void;
}

export interface ICameraController {
  /**
   * Обновляет состояние камеры (например, применяет damping, обрабатывает ввод).
   */
  update(): void;

  /**
   * Изменяет размеры viewport (при ресайзе окна).
   * @param width Новая ширина в пикселях.
   * @param height Новая высота в пикселях.
   */
  resize(width: number, height: number): void;

  /**
   * Возвращает текущую камеру Three.js.
   */
  getCamera(): THREE.PerspectiveCamera;

  /**
   * Устанавливает точку, на которую смотрит камера.
   * @param target Целевая позиция в 3D-пространстве.
   */
  lookAt(target: THREE.Vector3): void;

  /**
   * Перемещает камеру в указанную позицию.
   * @param position Новая позиция камеры.
   */
  setPosition(position: THREE.Vector3): void;

  /**
   * Сбрасывает камеру в начальное состояние (например, после смены объекта наблюдения).
   */
  reset(): void;

  /**
   * Включает/отключает управление камерой (например, при открытии модального окна).
   * @param enabled true — управление разрешено, false — заблокировано.
   */
  setEnabled(enabled: boolean): void;

  /**
   * Возвращает текущее положение камеры.
   */
  getPosition(): THREE.Vector3;

  /**
   * Возвращает направление, в котором смотрит камера.
   */
  getDirection(): THREE.Vector3;
}

--------------------------------------------------

--- Файл: src/rendering/object-factory.ts ---
import * as THREE from "three";
import { SpaceObject } from "../entities/space-object";
import { IObjectFactory, ITextureManager } from "./interfaces";
import { SIMULATION_CONFIG } from "../config/simulation-config";
import { PlatformAdapter } from "../adapters/platform-adapter";

export class ObjectFactory implements IObjectFactory {
  private textureManager: ITextureManager;

  constructor(textureManager: ITextureManager) {
    this.textureManager = textureManager;
  }

  createSpaceObject(spaceObject: SpaceObject): THREE.Mesh {
    const radiusPx =
      spaceObject.radius *
      SIMULATION_CONFIG.SCALE_DIST *
      SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE;

    const geometry = new THREE.SphereGeometry(radiusPx, 32, 32);
    let material: THREE.Material;

    if (spaceObject.texture) {
      const texture = this.textureManager.loadTexture(spaceObject.texture);

      material = new THREE.MeshPhongMaterial({
        map: texture,
        bumpMap: texture,
        bumpScale: 0.05,
        color: 0xffffff,
        shininess: 30,
        specular: new THREE.Color(0x333333),
      });
    } else {
      material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(spaceObject.color),
        shininess: 5,
        specular: new THREE.Color(0x333333),
      });
    }

    const mesh = new THREE.Mesh(geometry, material);
    mesh.name = spaceObject.name;

    return mesh;
  }

  createSpaceBackground(): THREE.Mesh {
    const spaceGeometry = new THREE.SphereGeometry(500000, 30, 30);
    const spaceTexture = this.textureManager.loadTexture("spacehigh.jpg");
    spaceTexture.anisotropy = 10;

    const spaceMaterial = new THREE.MeshBasicMaterial({
      map: spaceTexture,
      side: THREE.BackSide,
    });

    const background = new THREE.Mesh(spaceGeometry, spaceMaterial);
    background.scale.x = -1;
    background.scale.y = -1;
    background.scale.z = -1;
    background.rotation.x = -Math.PI * 0.37;
    background.rotation.y = -Math.PI * 0.88;
    background.rotation.z = Math.PI * 0.58;

    return background;
  }

  createLabelSprite(
    text: string,
    platformAdapter: PlatformAdapter
  ): THREE.Sprite | undefined {
    // Создаём canvas для текста
    const canvas = platformAdapter.getCanvas();

    if (!canvas) return;

    const context = canvas.getContext("2d")!;
    context.font = "24px Arial, sans-serif";
    context.textAlign = "center";

    // Рисуем текст
    context.fillStyle = "white";
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    // Создаём текстуру из canvas
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true; // Обязательно для первого рендера

    // Создаём материал и спрайт
    const material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthTest: true, // Чтобы скрывался за объектами
    });

    const sprite = new THREE.Sprite(material);

    return sprite;
  }
}

--------------------------------------------------

--- Файл: src/rendering/renderer-core.ts ---
import * as THREE from "three";
import { PlatformAdapter } from "../adapters/platform-adapter";
import { SpaceObject } from "../entities/space-object";
import { SIMULATION_CONFIG } from "../config/simulation-config";
import { ISceneManager } from "./interfaces";
import { ICameraController } from "./interfaces";
import { IObjectFactory } from "./interfaces";

export class RendererCore {
  private renderer: THREE.WebGLRenderer;
  private sceneManager: ISceneManager;
  private cameraController: ICameraController;
  private objectFactory: IObjectFactory;
  private spaceObjectMeshes: Map<string, THREE.Mesh> = new Map();
  private spaceObjectLabels: Map<string, THREE.Sprite> = new Map();
  private fpsElement: HTMLElement | null = null;
  private platformAdapter: PlatformAdapter;

  constructor(
    platformAdapter: PlatformAdapter,
    sceneManager: ISceneManager,
    cameraController: ICameraController,
    objectFactory: IObjectFactory
  ) {
    this.platformAdapter = platformAdapter;
    this.sceneManager = sceneManager;
    this.cameraController = cameraController;
    this.objectFactory = objectFactory;

    this.renderer = new THREE.WebGLRenderer({
      canvas: platformAdapter.getMainCanvas(),
      antialias: true,
    });
  }

  initialize(): void {
    this.renderer.setPixelRatio(this.platformAdapter.getPixelRatio());

    this.platformAdapter.onResize(() => {
      const width = this.platformAdapter.getWidth();
      const height = this.platformAdapter.getHeight();
      this.renderer.setSize(width, height);
      this.cameraController.resize(width, height);
    });

    this.renderer.setSize(
      this.platformAdapter.getWidth(),
      this.platformAdapter.getHeight()
    );
  }

  setFpsElement(element: HTMLElement): void {
    this.fpsElement = element;
  }

  initSpaceObjects(spaceObjects: SpaceObject[]): void {
    const background = this.objectFactory.createSpaceBackground();
    this.sceneManager.getScene().add(background);

    spaceObjects.forEach((obj) => {
      const mesh = this.objectFactory.createSpaceObject(obj);
      this.spaceObjectMeshes.set(obj.name, mesh);
      this.sceneManager.getScene().add(mesh);

      const labelSprite = this.objectFactory.createLabelSprite(
        obj.name,
        this.platformAdapter
      );

      if (labelSprite) {
        this.spaceObjectLabels.set(obj.name, labelSprite);
        this.sceneManager.getScene().add(labelSprite);
      }
    });
  }

  updateSpaceObjects(spaceObjects: SpaceObject[]): void {
    const scaleDist = SIMULATION_CONFIG.SCALE_DIST;

    spaceObjects.forEach((obj) => {
      const mesh = this.spaceObjectMeshes.get(obj.name);
      const label = this.spaceObjectLabels.get(obj.name);

      if (!mesh) {
        return;
      }

      mesh.position.set(
        obj.pos.x * scaleDist,
        obj.pos.y * scaleDist,
        obj.pos.z * scaleDist
      );

      if (label) {
        label.position.copy(mesh.position);
        label.position.y += obj.radius * scaleDist * 1.3;

        const distance = this.cameraController
          .getCamera()
          .position.distanceTo(label.position);

        label.scale.setScalar(distance / SIMULATION_CONFIG.LABEL_SCALE_FATOR);
      }
    });
  }

  render(deltaTime: number): void {
    this.cameraController.update();

    if (this.fpsElement) {
      const fps = 1000 / deltaTime;
      this.fpsElement.textContent = `FPS: ${Math.floor(fps)}`;
    }

    this.renderer.render(
      this.sceneManager.getScene(),
      this.cameraController.getCamera()
    );
  }

  dispose(): void {
    this.renderer.dispose();

    this.spaceObjectMeshes.forEach((mesh) => {
      mesh.geometry.dispose();
      (mesh.material as THREE.Material).dispose();
    });

    this.spaceObjectMeshes.clear();

    this.spaceObjectLabels.forEach((sprite) => {
      sprite.material.map?.dispose();
      sprite.material.dispose();
      this.sceneManager.getScene().remove(sprite);
    });

    this.spaceObjectLabels.clear();
  }
}

--------------------------------------------------

--- Файл: src/rendering/scene-manager.ts ---
import * as THREE from "three";
import { ISceneManager } from "./interfaces";
import { TextureManager } from "./texture-manager";

export class SceneManager implements ISceneManager {
  private scene: THREE.Scene;
  private textureLoader: TextureManager;

  constructor() {
    this.scene = new THREE.Scene();
    this.textureLoader = new TextureManager();
    this.scene.background = new THREE.Color(0x000000);

    this.setupLighting();
  }

  getScene(): THREE.Scene {
    return this.scene;
  }

  setupLighting(): void {
    const pointLight = new THREE.PointLight(0xffffff, 1.5);

    pointLight.position.set(0, 0, 0);
    this.scene.add(pointLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);

    this.scene.add(ambientLight);
  }
}

--------------------------------------------------

--- Файл: src/rendering/texture-manager.ts ---
import * as THREE from "three";
import { ITextureManager } from "./interfaces";

export class TextureManager implements ITextureManager {
  private textureLoader: THREE.TextureLoader;
  private cache: Map<string, THREE.Texture> = new Map();

  constructor() {
    this.textureLoader = new THREE.TextureLoader();
  }

  loadTexture(path: string): THREE.Texture {
    if (this.cache.has(path)) {
      return this.cache.get(path)!;
    }

    const texture = this.textureLoader.load(
      `src/textures/${path}`,
      () => console.log(`Текстура загружена: ${path}`),
      undefined,
      (error) => console.error(`Ошибка загрузки текстуры: ${path}`, error)
    );

    texture.anisotropy = 7;
    this.cache.set(path, texture);

    return texture;
  }
}

--------------------------------------------------

--- Файл: src/simulation/solar-system.ts ---
import { SpaceObject } from "../entities/space-object";
import { SPACE_OBJECTS } from "../config/space-objects";
import { SIMULATION_CONFIG } from "../config/simulation-config";

export class SolarSystem {
  private spaceObjects: SpaceObject[] = [];
  private dt: number;

  constructor(dt: number = SIMULATION_CONFIG.DEFAULT_DT) {
    this.dt = dt;
    this.initSpaceObjects();
  }

  private initSpaceObjects() {
    for (const config of SPACE_OBJECTS) {
      this.spaceObjects.push(
        new SpaceObject(
          config.name,
          config.mass,
          config.pos,
          config.vel,
          config.color,
          config.radius,
          config.texture
        )
      );
    }
  }

  getSpaceObjects() {
    return this.spaceObjects;
  }

  step(dt: number = this.dt) {
    const spaceObjectsCopy = [...this.spaceObjects];

    for (const spaceObject of this.spaceObjects) {
      spaceObject.update(dt, spaceObjectsCopy);
    }
  }
}

--------------------------------------------------

============================================================
CNHERNEHF ДИРЕКТОРИИ:
============================================================
adapters/
  browser-adapter.ts
  platform-adapter.ts
config/
  config-api.ts
  simulation-config.ts
  space-objects.ts
entities/
  celestial-body.ts
  interface.ts
  space-object.ts
main.ts
physics/
  gravity.ts
  vector.ts
rendering/
  camera-controller.ts
  interfaces.ts
  object-factory.ts
  renderer-core.ts
  scene-manager.ts
  texture-manager.ts
simulation/
  solar-system.ts
textures/
  corona.png
  earthhigh-min.jpg
  earthlow-min.jpg
  earthmedium-min.jpg
  jupiterhigh-min.jpg
  jupiterlow-min.jpg
  jupitermedium-min.jpg
  marshigh-min.jpg
  marslow-min.jpg
  marsmedium-min.jpg
  mercuryhigh-min.jpg
  mercurylow-min.jpg
  mercurymedium-min.jpg
  moonhigh-min.jpg
  moonlow-min.jpg
  moonmedium-min.jpg
  neptunehigh-min.jpg
  neptunelow-min.jpg
  neptunemedium-min.jpg
  plutohigh-min.jpg
  plutolow-min.jpg
  plutomedium-min.jpg
  saturn_ringhigh.png
  saturn_ringlow.png
  saturn_ringmedium.png
  saturnhigh-min.jpg
  saturnlow-min.jpg
  saturnmedium-min.jpg
  sol.png
  spacehigh.jpg
  spacelow.jpg
  spacemedium.jpg
  uranus_ringhigh.png
  uranus_ringlow.png
  uranus_ringmedium.png
  uranushigh-min.jpg
  uranuslow-min.jpg
  uranusmedium-min.jpg
  venushigh-min.jpg
  venuslow-min.jpg
  venusmedium-min.jpg