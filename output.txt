
--- Файл: src\ shaders\glow-shader.ts ---
export const GlowShader = {
  uniforms: {
    color: { value: [1.0, 1.0, 1.0] },
    radius: { value: 0.5 },
  },

  vertexShader: `
    varying vec2 vUv;


    void main() {
      vUv = uv; // uv — встроенный атрибут Three.js
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,

  fragmentShader: `
    uniform vec3 color;
    uniform float radius;
    varying vec2 vUv;

    void main() {
      vec2 center = vec2(0.5, 0.5);
      vec2 distVec = vUv - center;
      float distance = length(distVec);
      float normalizedDist = distance / radius;

      float alpha = 1.0 - smoothstep(0.0, 1.0, normalizedDist);
      gl_FragColor = vec4(color, alpha);
    }
  `,
};

--------------------------------------------------

--- Файл: src\ shaders\sun-shader.ts ---
export const SunShader = {
  uniforms: {
    uTime: { value: 0 },
    uTexture: { value: null },
    uNormalMap: { value: null },
    uEmissiveMap: { value: null },
    uScale: { value: 1.0 },
    uGlowIntensity: { value: 1.5 },
    uNoiseSpeed: { value: 0.3 },
    uGlowRadius: { value: 0.15 }, // Ширина свечения (15% от радиуса)
  },
  vertexShader: `
    varying vec2 vUv;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    precision mediump float;

    uniform sampler2D uTexture;
    uniform sampler2D uNormalMap;
    uniform sampler2D uEmissiveMap;
    uniform float uTime;
    uniform float uScale;
    uniform float uGlowIntensity;
    uniform float uNoiseSpeed;
    uniform float uGlowRadius; // Объявляем униформу для ширины свечения

    varying vec2 vUv;
    varying vec3 vNormal;

    // Генератор шума
    float rand(vec2 co) {
        return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }

    float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        float a = rand(i);
        float b = rand(i + vec2(1.0, 0.0));
        float c = rand(i + vec2(0.0, 1.0));
        float d = rand(i + vec2(1.0, 1.0));

        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
    }

    void main() {
        // Базовая текстура
        vec4 color = texture2D(uTexture, vUv * uScale);

        // Карта нормалей
        vec3 normalMap = texture2D(uNormalMap, vUv * uScale).rgb;
        normalMap = normalMap * 2.0 - 1.0;
        vec3 normal = normalize(vNormal + normalMap * 0.1);


        // Эмиссивная карта
        vec4 emissive = texture2D(uEmissiveMap, vUv * uScale);
        color.rgb += emissive.rgb * uGlowIntensity;
        color.rgb *= 1.0 + emissive.a * 0.5;


        // Анимация грануляции
        float noiseValue = noise(vUv * 10.0 + uTime * uNoiseSpeed);
        color.rgb *= 0.95 + noiseValue * 0.1;


        // Эффект короны (свечение по краям)
        float rim = max(0.0, 1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)));
        rim = pow(rim, 3.0) * uGlowIntensity;
        color.rgb += vec3(1.0, 0.7, 0.3) * rim;


        // === СВЕЧЕНИЕ ВОКРУГ СОЛНЦА ===
        vec2 centerUV = vUv * 2.0 - vec2(1.0); // Нормализуем UV в [-1, 1]
        float distanceFromCenter = length(centerUV); // Расстояние от центра


        float sunEdge = 1.0;                  // Край Солнца (в нормализованных координатах)
        float glowWidth = uGlowRadius;         // Ширина свечения из униформы


        // Маска: плавный переход от края Солнца наружу
        float glowMask = smoothstep(
            sunEdge,
            sunEdge + glowWidth,
            distanceFromCenter
        );

        // Цвет свечения (можно менять под стиль)
        vec3 glowColor = vec3(1.0, 0.6, 0.2); // Тёплый оранжевый


        // Добавляем свечение к основному цвету
        color.rgb += glowColor * 2.0 * (1.0 - glowMask);


        gl_FragColor = color;
    }
  `,
};

--------------------------------------------------

--- Файл: src\adapters\browser-adapter.ts ---
import { CanvasName, Command, PlatformAdapter } from "./platform-adapter";

export class BrowserAdapter implements PlatformAdapter {
  private resizeCallbacks: Set<() => void> = new Set();
  private canvasList = new Map<string, HTMLCanvasElement>();

  private keyList = new Map<string, Command>([
    ["KeyW", Command.forward],
    ["KeyS", Command.back],
    ["KeyA", Command.left],
    ["KeyD", Command.right],
    ["KeyQ", Command.up],
    ["KeyE", Command.down],
    ["KeyM", Command.zoomMap],
  ]);

  constructor() {
    this.createCanvas(CanvasName.MAIN_SCENE);
  }

  getCanvas(canvasName: CanvasName) {
    const canvas = this.canvasList.get(canvasName);

    if (canvas) {
      return canvas;
    }

    return this.createCanvas(canvasName);
  }

  getCanvasWithoutAddToDom() {
    return document.createElement("canvas");
  }

  getWidth(): number {
    return Math.max(window.innerWidth, 400);
  }

  getHeight(): number {
    return Math.max(window.innerHeight, 300);
  }

  getPixelRatio(): number {
    return window.devicePixelRatio;
  }

  onResize(callback: () => void): void {
    this.resizeCallbacks.add(callback);
    window.addEventListener("resize", callback);
  }

  offResize(callback: () => void): void {
    this.resizeCallbacks.delete(callback);
    window.removeEventListener("resize", callback);
  }

  appendToDom(element: HTMLElement | undefined): void {
    if (element) {
      document.body.appendChild(element);
    }
  }

  requestAnimationFrame(callback: FrameRequestCallback): void {
    window.requestAnimationFrame(callback);
  }

  onPressButton(callback: (value: string) => void): void {
    window.addEventListener("keydown", (e) => {
      const command = this.keyList.get(e.code);
      if (command) callback(command);
    });
  }

  onReleaseButton(callback: (value: string) => void): void {
    window.addEventListener("keyup", (e) => {
      const command = this.keyList.get(e.code);
      if (command) callback(command);
    });
  }

  onZoom(callback: (value: number) => void, canvasName: CanvasName): void {
    this.canvasList.get(canvasName)?.addEventListener("wheel", (e) => {
      callback(e.deltaY);
    });
  }

  onMove(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void {
    this.canvasList.get(canvasName)?.addEventListener("mousemove", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onPress(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void {
    this.canvasList.get(canvasName)?.addEventListener("mousedown", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onRelease(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void {
    this.canvasList.get(canvasName)?.addEventListener("mouseup", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  onLeave(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void {
    this.canvasList.get(canvasName)?.addEventListener("mouseleave", (e) => {
      callback(e.clientX, e.clientY);
    });
  }

  private createCanvas(canvasName: CanvasName) {
    const canvas = document.createElement("canvas");

    this.canvasList.set(canvasName, canvas);
    document.body.appendChild(canvas);

    return canvas;
  }
}

--------------------------------------------------

--- Файл: src\adapters\platform-adapter.ts ---
export const enum CanvasName {
  MAIN_SCENE = "MAIN_SCENE",
  MINI_MAP = "MINI_MAP",
  FPS = "FPS",
}

export const enum Command {
  forward = "forward",
  back = "back",
  left = "left",
  right = "right",
  up = "up",
  down = "down",
  zoomMap = "zoomMap",
}
export interface PlatformAdapter {
  getCanvas(canvasName: CanvasName): HTMLCanvasElement;
  getCanvasWithoutAddToDom(): HTMLCanvasElement;
  getWidth(): number;
  getHeight(): number;
  getPixelRatio(): number;
  onResize(callback: () => void): void;
  offResize(callback: () => void): void;
  appendToDom(element: HTMLElement | undefined): void;
  requestAnimationFrame(callback: FrameRequestCallback): void;

  onPressButton(callback: (value: string) => void): void;
  onReleaseButton(callback: (value: string) => void): void;
  onZoom(callback: (value: number) => void, canvasName: CanvasName): void;

  onMove(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void;

  onPress(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void;

  onRelease(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void;

  onLeave(
    callback: (x: number, y: number) => void,
    canvasName: CanvasName
  ): void;
}

--------------------------------------------------

--- Файл: src\config\config-api.ts ---
import { Vector3D } from "../physics/vector";
import { SIMULATION_CONFIG } from "./simulation-config";

export interface SimulationConfig {
  SIMULATION_DT: number;
  DEFAULT_DT: number;
  MAX_DT: number;
  AU_IN_PX: number;
  OBJECTS_RADIUS_SCALE: number;
}

export class ConfigAPI {
  static setSimulationSpeed(factor: number): void {
    if (factor <= 0) {
      throw new Error("Simulation speed factor must be positive");
    }
    SIMULATION_CONFIG.SIMULATION_DT = factor;
  }

  static getSimulationSpeed(): number {
    return SIMULATION_CONFIG.SIMULATION_DT;
  }

  static setScale(auInPx: number): void {
    if (auInPx <= 0) {
      throw new Error("AU in pixels must be positive");
    }
    SIMULATION_CONFIG.AU_IN_PX = auInPx;
  }

  static getScale(): number {
    return SIMULATION_CONFIG.AU_IN_PX;
  }

  static setSpaceObjectScale(scale: number): void {
    if (scale <= 0) {
      throw new Error("SpaceObject radius scale must be positive");
    }
    SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE = scale;
  }

  static getSpaceObjectScale(): number {
    return SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE;
  }

  static getLabelScaleFactor(): number {
    return SIMULATION_CONFIG.LABEL_SCALE_FATOR;
  }

  static setLabelScaleFactor(factor: number): void {
    if (factor <= 0) {
      throw new Error("Label scale factor must be positive");
    }
    SIMULATION_CONFIG.LABEL_SCALE_FATOR = factor;
  }

  static getSpeedFactor(): number {
    return SIMULATION_CONFIG.SPEED_FACTOR * 10000000;
  }

  static setSpeedFactor(factor: number): void {
    if (factor <= 0) {
      throw new Error("Speed factor must be positive");
    }
    SIMULATION_CONFIG.SPEED_FACTOR = factor / 10000000;
  }

  static getImpulseStrength(): number {
    return SIMULATION_CONFIG.IMPULSE_STRENGTH;
  }

  static setImpulseStrength(factor: number): void {
    if (factor <= 0) {
      throw new Error("Impulse strength must be positive");
    }
    SIMULATION_CONFIG.IMPULSE_STRENGTH = factor;
  }

  static resetSimulationConfig(): void {
    SIMULATION_CONFIG.SIMULATION_DT = 1;
    SIMULATION_CONFIG.DEFAULT_DT = 86400;
    SIMULATION_CONFIG.MAX_DT = 864000;
    SIMULATION_CONFIG.AU_IN_PX = 100;
    SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE = 1;
  }
}

--------------------------------------------------

--- Файл: src\config\simulation-config.ts ---
export const SIMULATION_CONFIG = {
  SIMULATION_DT: 1, // шаг симуляции (x реального времени)
  DEFAULT_DT: 86400,
  MAX_DT: 864000, // макс. шаг симуляции (защита от фризов)

  AU_IN_PX: 500, // Сколько пикселей соответствует 1 а.е. (настраивается пользователем)
  AU: 1.496e11, // 1 а.е. = 1.496e11 м

  OBJECTS_RADIUS_SCALE: 1, // Коэффициент для увеличения радиусов планет (по умолчанию = 1 — строго пропорционально)
  LABEL_SCALE_FATOR: 7,
  SPEED_FACTOR: 0.0000001,
  IMPULSE_STRENGTH: 500,

  // Масштаб для расстояний: 1 м = ? px
  get SCALE_DIST() {
    return this.AU_IN_PX / this.AU;
  },
};

--------------------------------------------------

--- Файл: src\config\space-objects.ts ---
import { CelestialBody } from "../entities/celestial-body";
import { Vector3D } from "../physics/vector";

// 1. Солнце
const sun = new CelestialBody({
  name: "Sun",
  pos: new Vector3D(0, 0, 0),
  vel: new Vector3D(0, 0, 0),
  radius: 696340000,
  mass: 1.989e30,
  texture: "sun.jpg",
  rotationPeriod: 25.05,
  axialTilt: 7.25,
});

// 2. Меркурий
const mercury = new CelestialBody({
  name: "Mercury",
  pos: new Vector3D(5.791e10, 0, 0),
  vel: new Vector3D(0, 0, -47362),
  radius: 2439700,
  mass: 3.3011e23,
  texture: "mercury.jpg",
  rotationPeriod: 58.65,
  axialTilt: 0.01,
});

// 3. Венера
const venus = new CelestialBody({
  name: "Venus",
  pos: new Vector3D(1.082e11, 0, 0),
  vel: new Vector3D(0, 0, -35020),
  radius: 6051800,
  mass: 4.8675e24,
  texture: "venus.jpg",
  rotationPeriod: -243.02,
  axialTilt: 177.36,
});

// 4. Земля + Луна
const earth = new CelestialBody({
  name: "Earth",
  pos: new Vector3D(-4671000, 0, 0),
  vel: new Vector3D(0, -12.6, 0),
  radius: 6371000,
  mass: 5.972e24,
  texture: "earth.jpg",
  rotationPeriod: 1.0,
  axialTilt: 23.44,
});

const moon = new CelestialBody({
  name: "Moon",
  pos: new Vector3D(379729000, 0, 0),
  vel: new Vector3D(0, 1022, 0),
  radius: 1737000,
  mass: 7.342e22,
  texture: "moon.jpg",
  rotationPeriod: 27.32,
  axialTilt: 6.68,
});

const camera = new CelestialBody({
  name: "Camera",
  pos: new Vector3D(1.4962e11, 0, 0),
  vel: new Vector3D(0, 0, -29783),
  radius: 1737000,
  mass: 1000,
});

const earthMoonSystem = new CelestialBody({
  name: "EarthMoonSystem",
  pos: new Vector3D(1.496e11, 0, 0),
  vel: new Vector3D(0, 0, -29783),
  radius: 3.844e8 + 6.371e6 + 1.737e6,
  children: [earth, moon],
});

// 5. Марс + спутники
const mars = new CelestialBody({
  name: "Mars",
  pos: new Vector3D(-9378000, 0, 0),
  vel: new Vector3D(0, -0.14, 0),
  radius: 3389500,
  mass: 6.417e23,
  texture: "mars.jpg",
  rotationPeriod: 1.026,
  axialTilt: 25.19,
});

const phobos = new CelestialBody({
  name: "Phobos",
  pos: new Vector3D(9284220, 0, 0),
  vel: new Vector3D(0, 2138, 0),
  radius: 11267,
  mass: 1.07e16,
  texture: "phobos.jpg",
});

const deimos = new CelestialBody({
  name: "Deimos",
  pos: new Vector3D(23460000, 0, 0),
  vel: new Vector3D(0, 1352, 0),
  radius: 6200,
  mass: 1.48e15,
  texture: "deimos.jpg",
});

const marsSystem = new CelestialBody({
  name: "MarsSystem",
  pos: new Vector3D(2.279e11, 0, 0),
  vel: new Vector3D(0, 0, -24077),
  radius: 23460e3 + 6200,
  children: [mars, phobos, deimos],
});

// 6. Юпитер + галилеевы спутники
const jupiter = new CelestialBody({
  name: "Jupiter",
  pos: new Vector3D(-1980000, 0, 0),
  vel: new Vector3D(0, -2.7, 0),
  radius: 69911000,
  mass: 1.898e27,
  texture: "jupiter.jpg",
  rotationPeriod: 0.414,
  axialTilt: 3.13,
});

const io = new CelestialBody({
  name: "Io",
  pos: new Vector3D(419720000, 0, 0),
  vel: new Vector3D(0, 17334, 0),
  radius: 1821500,
  mass: 8.93e22,
  texture: "io.jpg",
});

const europa = new CelestialBody({
  name: "Europa",
  pos: new Vector3D(671034000, 0, 0),
  vel: new Vector3D(0, 13740, 0),
  radius: 1560800,
  mass: 4.8e22,
  texture: "europa.jpg",
});

const ganymede = new CelestialBody({
  name: "Ganymede",
  pos: new Vector3D(1070400000, 0, 0),
  vel: new Vector3D(0, 10880, 0),
  radius: 2634100,
  mass: 1.5e23,
  texture: "ganymede.jpg",
});

const callisto = new CelestialBody({
  name: "Callisto",
  pos: new Vector3D(1882700000, 0, 0),
  vel: new Vector3D(0, 8204, 0),
  radius: 2410300,
  mass: 1.08e23,
  texture: "callisto.jpg",
});

const jupiterSystem = new CelestialBody({
  name: "JupiterSystem",
  pos: new Vector3D(7.785e11, 0, 0),
  vel: new Vector3D(0, 0, -13070),
  radius: 1.88e9,
  children: [jupiter, io, europa, ganymede, callisto],
});

// 7. Сатурн + Титан
const saturn = new CelestialBody({
  name: "Saturn",
  pos: new Vector3D(-291000, 0, 0),
  vel: new Vector3D(0, -0.4, 0),
  radius: 58232000,
  mass: 5.683e26,
  texture: "saturn.jpg",
  rotationPeriod: 0.444,
  axialTilt: 26.73,
});

const titan = new CelestialBody({
  name: "Titan",
  pos: new Vector3D(1221709000, 0, 0),
  vel: new Vector3D(0, 5570, 0),
  radius: 2574700,
  mass: 1.35e23,
  texture: "titan.jpg",
});

const saturnSystem = new CelestialBody({
  name: "SaturnSystem",
  pos: new Vector3D(1.434e12, 0, 0),
  vel: new Vector3D(0, 0, -9690),
  radius: 1.22e9,
  children: [saturn, titan],
});

// 8. Уран (с системой спутников, упрощённо)
const uranus = new CelestialBody({
  name: "Uranus",
  pos: new Vector3D(0, 0, 0),
  vel: new Vector3D(0, 0, 0),
  radius: 25362000,
  mass: 8.681e25,
  texture: "uranus.jpg",
  rotationPeriod: -0.718,
  axialTilt: 97.77,
});

const uranusSystem = new CelestialBody({
  name: "UranusSystem",
  pos: new Vector3D(2.871e12, 0, 0),
  vel: new Vector3D(0, 0, -6810),
  radius: 5e8,
  children: [uranus],
});

// 9. Нептун (с системой спутников, упрощённо)
const neptune = new CelestialBody({
  name: "Neptune",
  pos: new Vector3D(0, 0, 0),
  vel: new Vector3D(0, 0, 0),
  radius: 24622000,
  mass: 1.024e26,
  texture: "neptune.jpg",
  rotationPeriod: 0.671,
  axialTilt: 28.32,
});

const neptuneSystem = new CelestialBody({
  name: "NeptuneSystem",
  pos: new Vector3D(4.495e12, 0, 0),
  vel: new Vector3D(0, 0, -5430),
  radius: 4e8,
  children: [neptune],
});

// === СОЛНЕЧНАЯ СИСТЕМА (итоговый объект) ===
export const spaceObjects = new CelestialBody({
  name: "SolarSystem",
  pos: new Vector3D(0, 0, 0),
  vel: new Vector3D(0, 0, 0),
  radius: 4.5e12,
  children: [
    camera,
    sun,
    mercury,
    venus,
    earthMoonSystem,
    // marsSystem,
    // jupiterSystem,
    // saturnSystem,
    // uranusSystem,
    // neptuneSystem,
  ],
});

--------------------------------------------------

--- Файл: src\entities\celestial-body.ts ---
import { Vector3D } from "../physics/vector";
import { ICelestialBody } from "./interface";

export class CelestialBody implements ICelestialBody {
  name: string;
  pos: Vector3D;
  vel: Vector3D;
  radius: number;
  mass?: number;
  texture?: string;
  rotationPeriod?: number;
  axialTilt?: number;
  children?: ICelestialBody[];

  constructor(data: Omit<ICelestialBody, "totalMass">) {
    this.name = data.name;
    this.pos = data.pos;
    this.vel = data.vel;
    this.radius = data.radius;
    this.mass = data.mass;
    this.texture = data.texture;
    this.rotationPeriod = data.rotationPeriod;
    this.axialTilt = data.axialTilt;
    this.children = data.children;
  }

  get totalMass(): number {
    if (typeof this.mass === "number") return this.mass;
    if (this.children)
      return this.children.reduce((sum, child) => sum + child.totalMass, 0);
    return 0;
  }
}

--------------------------------------------------

--- Файл: src\entities\interface.ts ---
import { Vector3D } from "../physics/vector";

export interface ISpaceObject {
  name: string;
  mass: number;
  pos: Vector3D;
  vel: Vector3D;
  color: string;
  radius: number; // в метрах
  texture?: string;
  rotationPeriod?: number; // период вращения в земных сутках
  axialTilt?: number;
}

export interface ICelestialBody {
  name: string;
  pos: Vector3D;
  vel: Vector3D;
  radius: number;
  mass?: number; // масса только для «листовых» тел
  texture?: string;
  rotationPeriod?: number;
  axialTilt?: number;
  children?: ICelestialBody[];
  get totalMass(): number;
}

--------------------------------------------------

--- Файл: src\entities\space-object.ts ---
import { CelestialBody } from "./celestial-body";
import { Vector3D } from "../physics/vector";
import { GravityCalculator } from "../physics/gravity";

export class SpaceObject extends CelestialBody {
  public relativePos: Vector3D;
  public relativeVel: Vector3D;
  public parent: SpaceObject | null = null;

  constructor(
    name: string,
    mass: number,
    pos: Vector3D,
    vel: Vector3D,
    relativePos: Vector3D,
    relativeVel: Vector3D,
    color: string | null,
    radius: number,
    texture: string,
    rotationPeriod: number,
    axialTilt: number,
    totalMass: number,
    children: CelestialBody[]
  ) {
    super({
      name,
      mass,
      pos,
      vel,
      color,
      radius,
      texture,
      rotationPeriod,
      axialTilt,
      children,
    });
    this.relativePos = relativePos.clone();
    this.relativeVel = relativeVel.clone();
  }

  public update(dt: number, allObjects: SpaceObject[]): void {
    if (this.parent) {
      this.pos = this.parent.pos.add(this.relativePos);
      this.vel = this.parent.vel.add(this.relativeVel);
      return;
    }

    const acc = GravityCalculator.calculateAcceleration(this, allObjects);
    this.vel = this.vel.add(acc.multiply(dt));
    this.pos = this.pos.add(this.vel.multiply(dt));
  }

  public isSatellite(): boolean {
    return this.parent !== null;
  }

  public updateChildrenPositions(
    dt: number,
    parent: SpaceObject,
    allObjects: SpaceObject[]
  ): void {
    for (const child of parent.children!) {
      const childObject = allObjects.find((obj) => obj.name === child.name);

      if (!childObject) {
        console.warn(`Объект "${child.name}" не найден в системе`);
        continue;
      }

      childObject.pos = parent.pos.add(childObject.relativePos);
      childObject.vel = parent.vel.add(childObject.relativeVel);
    }
  }
}

--------------------------------------------------

--- Файл: src\main.ts ---
import { PlatformAdapter } from "./adapters/platform-adapter";
import { BrowserAdapter } from "./adapters/browser-adapter";
import { SolarSystem } from "./simulation/solar-system";
import { SIMULATION_CONFIG } from "./config/simulation-config";
import { ConfigAPI } from "./config/config-api";

import { SceneManager } from "./rendering/scene-manager";
import { CameraController } from "./rendering/camera-controller";
import { TextureManager } from "./rendering/texture-manager";
import { ObjectFactory } from "./rendering/object-factory";
import { RendererCore } from "./rendering/renderer-core";
import { MiniMap } from "./rendering/mini-map";
import { FPS } from "./rendering/fps";

export function runSimulation(platformAdapter: PlatformAdapter) {
  const system = new SolarSystem(SIMULATION_CONFIG.MAX_DT);
  const sceneManager = new SceneManager();
  const textureManager = new TextureManager();
  const cameraController = new CameraController(platformAdapter, system);
  const miniMap = new MiniMap(platformAdapter);
  const fps = new FPS(platformAdapter);

  const objectFactory = new ObjectFactory(
    platformAdapter,
    textureManager,
    sceneManager,
    cameraController,
    system
  );

  const renderer = new RendererCore(
    platformAdapter,
    sceneManager,
    cameraController,
    objectFactory,
    miniMap,
    system,
    fps
  );

  renderer.init();

  let lastTimestamp = 0;

  function animate(currentTimestamp: number) {
    const deltaTime = currentTimestamp - lastTimestamp;
    lastTimestamp = currentTimestamp;

    system.step(
      Math.min(
        (deltaTime / 1000) * SIMULATION_CONFIG.SIMULATION_DT,
        SIMULATION_CONFIG.MAX_DT
      )
    );

    renderer.render(deltaTime);

    platformAdapter.requestAnimationFrame(animate);
  }

  platformAdapter.requestAnimationFrame(animate);
}

function initControls() {
  const speedSlider = document.getElementById(
    "speed-slider"
  ) as HTMLInputElement;
  const speedValue = document.getElementById("speed-value");

  if (speedValue) {
    const getSimulationSpeed = ConfigAPI.getSimulationSpeed();
    speedSlider.value = getSimulationSpeed.toString();
    speedValue.textContent = getSimulationSpeed.toString();

    speedSlider.addEventListener("input", () => {
      const value = parseInt(speedSlider.value, 10);
      ConfigAPI.setSimulationSpeed(value);
      speedValue.textContent = value.toString();
    });
  }

  // Управление масштабом меток (labelScaleFactor)
  const labelScaleSlider = document.getElementById(
    "label-scale-slider"
  ) as HTMLInputElement;
  const labelScaleValue = document.getElementById("label-scale-value");

  if (labelScaleSlider && labelScaleValue) {
    const labelScaleFactor = ConfigAPI.getLabelScaleFactor().toString();
    labelScaleSlider.value = labelScaleFactor;
    labelScaleValue.textContent = labelScaleFactor;

    labelScaleSlider.addEventListener("input", () => {
      const value = parseFloat(labelScaleSlider.value);
      ConfigAPI.setLabelScaleFactor(value);
      labelScaleValue.textContent = value.toString();
    });
  }

  // Управление impulseStrength (множитель ускорения)
  const impulseStrength = document.getElementById(
    "impulse-strength-slider"
  ) as HTMLInputElement;
  const speedFactorValue = document.getElementById("impulse-strength-value");

  if (impulseStrength && speedFactorValue) {
    const speedFactor = ConfigAPI.getImpulseStrength().toString();
    impulseStrength.value = speedFactor;
    speedFactorValue.textContent = speedFactor;

    impulseStrength.addEventListener("input", () => {
      const value = parseFloat(impulseStrength.value);
      ConfigAPI.setImpulseStrength(value);
      speedFactorValue.textContent = value.toString();
    });
  }
}

const platformAdapter = new BrowserAdapter();
runSimulation(platformAdapter);
initControls();

--------------------------------------------------

--- Файл: src\physics\gravity.ts ---
import { SpaceObject } from "../entities/space-object";
import { Vector3D } from "./vector";

export class GravityCalculator {
  static readonly G = 6.6743e-11; // м³·кг⁻¹·с⁻²

  static calculateAcceleration(
    spaceObject: SpaceObject,
    others: SpaceObject[]
  ): Vector3D {
    let acc = new Vector3D();

    for (const other of others) {
      if (other === spaceObject) continue;
      if (other.children) continue; // пропускаем контейнеры

      const r = other.pos.subtract(spaceObject.pos); // вектор к другому телу
      const distSq = r.magnitudeSquared(); // используем метод Vector3D

      if (distSq < 1e-20) continue; // слишком близко — пропускаем

      const dist = Math.sqrt(distSq); // корень нужен только для minDist
      const minDist = spaceObject.radius + other.radius;

      if (dist < minDist) {
        console.warn(`Столкновение: ${spaceObject.name} и ${other.name}`);
        continue;
      }

      // Ускорение: a = G * M / r²
      const accMagnitude = (this.G * other.totalMass) / distSq;
      acc = acc.add(r.normalize().multiply(accMagnitude));
    }

    return acc;
  }
}

--------------------------------------------------

--- Файл: src\physics\vector.ts ---
export class Vector3D {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  // Арифметические операции
  add(v: Vector3D): Vector3D {
    return new Vector3D(this.x + v.x, this.y + v.y, this.z + v.z);
  }

  subtract(v: Vector3D): Vector3D {
    return new Vector3D(this.x - v.x, this.y - v.y, this.z - v.z);
  }

  multiply(scalar: number): Vector3D {
    return new Vector3D(this.x * scalar, this.y * scalar, this.z * scalar);
  }

  divide(scalar: number): Vector3D {
    if (scalar === 0) throw new Error("Division by zero");
    return new Vector3D(this.x / scalar, this.y / scalar, this.z / scalar);
  }

  // Векторные операции
  dot(v: Vector3D): number {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }

  cross(v: Vector3D): Vector3D {
    return new Vector3D(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }

  // Нормализация и длина
  magnitude(): number {
    return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);
  }

  magnitudeSquared(): number {
    return this.x ** 2 + this.y ** 2 + this.z ** 2;
  }

  normalize(): Vector3D {
    const mag = this.magnitude();
    if (mag === 0) return new Vector3D();
    return this.divide(mag);
  }

  isNormalized(): boolean {
    return Math.abs(this.magnitude() - 1) < 1e-6;
  }

  // Сравнение
  equals(v: Vector3D, epsilon: number = 1e-6): boolean {
    return (
      Math.abs(this.x - v.x) < epsilon &&
      Math.abs(this.y - v.y) < epsilon &&
      Math.abs(this.z - v.z) < epsilon
    );
  }

  // Клонирование и копирование
  clone(): Vector3D {
    return new Vector3D(this.x, this.y, this.z);
  }

  copyFrom(v: Vector3D): void {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  }

  set(x: number, y: number, z: number): void {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  // Прочие полезные методы
  negate(): Vector3D {
    return new Vector3D(-this.x, -this.y, -this.z);
  }

  lerp(v: Vector3D, t: number): Vector3D {
    return this.add(v.subtract(this).multiply(t));
  }

  distanceTo(v: Vector3D): number {
    return this.subtract(v).magnitude();
  }

  distanceSquaredTo(v: Vector3D): number {
    return this.subtract(v).magnitudeSquared();
  }

  angleTo(v: Vector3D): number {
    const dot = this.dot(v);
    const magA = this.magnitude();
    const magB = v.magnitude();
    if (magA === 0 || magB === 0) return 0;
    return Math.acos(dot / (magA * magB));
  }
}

--------------------------------------------------

--- Файл: src\rendering\camera-controller.ts ---
import * as THREE from "three";
import { ICameraController } from "./interfaces";
import {
  CanvasName,
  Command,
  PlatformAdapter,
} from "../adapters/platform-adapter";
import { SIMULATION_CONFIG } from "../config/simulation-config";
import { SolarSystem } from "../simulation/solar-system";

export class CameraController implements ICameraController {
  private camera: THREE.PerspectiveCamera;
  private target: THREE.Vector3 = new THREE.Vector3(0, 0, 0);
  private velocity: THREE.Vector2 = new THREE.Vector2(0, 0);
  private mousePrev: THREE.Vector2 = new THREE.Vector2();
  private mouseCurr: THREE.Vector2 = new THREE.Vector2();

  private yaw: number = 0;
  private pitch: number = 0;
  private commands = new Set();
  private isMouseDown: boolean = false;

  constructor(
    platformAdapter: PlatformAdapter,
    private solarSystem: SolarSystem
  ) {
    this.camera = new THREE.PerspectiveCamera(
      65,
      platformAdapter.getWidth() / platformAdapter.getHeight(),
      0.001,
      50000000000
    );

    this.setupEvents(platformAdapter);
    this.updateCamera();
  }

  public update(): void {
    this.updateCamera();
  }

  public resize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
  }

  public getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  public lookAt(target: THREE.Vector3): void {
    this.target.copy(target);
    this.updateCamera();
  }

  public setPosition(position: THREE.Vector3): void {
    this.camera.position.copy(position);
    this.target.copy(position);
    this.updateCamera();
  }

  public getPosition(): THREE.Vector3 {
    return this.camera.position;
  }

  public getDirection(): THREE.Vector3 {
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    return direction;
  }

  private setupEvents(platformAdapter: PlatformAdapter): void {
    platformAdapter.onPress((x, y) => {
      this.isMouseDown = true;
      this.mousePrev.set(x, y);
    }, CanvasName.MAIN_SCENE);

    platformAdapter.onRelease(() => {
      this.isMouseDown = false;
    }, CanvasName.MAIN_SCENE);

    platformAdapter.onLeave(() => {
      this.isMouseDown = false;
    }, CanvasName.MAIN_SCENE);

    platformAdapter.onMove((x, y) => {
      if (this.isMouseDown) {
        this.mouseCurr.set(x, y);
        this.handleMouseRotate();
        this.mousePrev.copy(this.mouseCurr);
      }
    }, CanvasName.MAIN_SCENE);

    platformAdapter.onZoom((value) => {
      const zoomSpeed = 10;
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(this.camera.quaternion);
      this.target.addScaledVector(direction, value * 0.01 * zoomSpeed);
      this.updateCamera();
    }, CanvasName.MAIN_SCENE);

    platformAdapter.onPressButton((value) => {
      this.commands.add(value);

      const { cameraZAxis, cameraXAxis, cameraYAxis } = this.getCameraAxes();

      let impulse = new THREE.Vector3(0, 0, 0);
      const impulseStrength = SIMULATION_CONFIG.IMPULSE_STRENGTH;

      if (this.commands.has(Command.forward))
        impulse.copy(cameraZAxis).multiplyScalar(impulseStrength);

      if (this.commands.has(Command.back))
        impulse.copy(cameraZAxis).multiplyScalar(-impulseStrength);

      if (this.commands.has(Command.left))
        impulse.copy(cameraXAxis).multiplyScalar(-impulseStrength);

      if (this.commands.has(Command.right))
        impulse.copy(cameraXAxis).multiplyScalar(impulseStrength);

      if (this.commands.has(Command.up))
        impulse.copy(cameraYAxis).multiplyScalar(impulseStrength);

      if (this.commands.has(Command.down))
        impulse.copy(cameraYAxis).multiplyScalar(-impulseStrength);


      this.solarSystem.applyCameraVelocityImpulse(
        impulse.x,
        impulse.y,
        impulse.z
      );
    });

    platformAdapter.onReleaseButton((value) => {
      this.commands.delete(value);
    });
  }

  private handleMouseRotate(): void {
    const delta = new THREE.Vector2()
      .subVectors(this.mouseCurr, this.mousePrev)
      .multiplyScalar(0.002);

    this.velocity.set(-delta.x, delta.y);
  }

  private updateCamera(): void {
    this.yaw += this.velocity.x;
    this.pitch += this.velocity.y;

    this.pitch = Math.max(
      -Math.PI / 2 + 0.01,
      Math.min(Math.PI / 2 - 0.01, this.pitch)
    );

    this.velocity.set(0, 0);

    const rotationMatrix = new THREE.Matrix4();
    const pitchMatrix = new THREE.Matrix4();

    rotationMatrix.makeRotationY(this.yaw);
    pitchMatrix.makeRotationX(this.pitch);
    rotationMatrix.multiply(pitchMatrix);

    this.camera.quaternion.setFromRotationMatrix(rotationMatrix);
    this.camera.position.copy(this.target);

    this.camera.lookAt(
      this.target
        .clone()
        .add(new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix))
    );
  }

  private getCameraAxes(): {
    cameraZAxis: THREE.Vector3;
    cameraXAxis: THREE.Vector3;
    cameraYAxis: THREE.Vector3;
  } {
    const cameraZAxis = new THREE.Vector3(0, 0, -1);
    const cameraXAxis = new THREE.Vector3(1, 0, 0);
    const cameraYAxis = new THREE.Vector3(0, 1, 0);

    cameraZAxis.applyQuaternion(this.camera.quaternion);
    cameraXAxis.applyQuaternion(this.camera.quaternion);
    cameraYAxis.applyQuaternion(this.camera.quaternion);

    return { cameraZAxis, cameraXAxis, cameraYAxis };
  }
}

--------------------------------------------------

--- Файл: src\rendering\fps.ts ---
import { CanvasName, PlatformAdapter } from "../adapters/platform-adapter";

export class FPS {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D | null = null;

  constructor(private platformAdapter: PlatformAdapter) {
    this.canvas = this.platformAdapter.getCanvas(CanvasName.FPS);
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "10px";
    this.canvas.style.right = "10px";
    this.canvas.style.pointerEvents = "none";
    this.canvas.width = 100;
    this.canvas.height = 30;

    this.ctx = this.canvas.getContext("2d");
  }

  public init() {
    this.platformAdapter.appendToDom(this.canvas);
  }

  public render(deltaTime: number) {
    if (!this.canvas || !this.ctx) {
      return;
    }

    const fps = 1000 / deltaTime;
    const fpsText = `FPS: ${Math.floor(fps)}`;

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.font = "14px monospace";
    this.ctx.textAlign = "right";
    this.ctx.textBaseline = "top";
    this.ctx.fillStyle = "lime";

    this.ctx.fillText(fpsText, this.canvas.width - 5, 5);
  }
}

--------------------------------------------------

--- Файл: src\rendering\interfaces.ts ---
import * as THREE from "three";
import { SpaceObject } from "../entities/space-object";
import { PlatformAdapter } from "../adapters/platform-adapter";

export interface ITextureManager {
  loadTexture(path: string): THREE.Texture;
}

export interface IObjectFactory {
  init(): void;
  render(deltaTime: number): void;
}

export interface ISceneManager {
  getScene(): THREE.Scene;
  setupLighting(): void;
}

export interface ICameraController {
  update(): void;
  resize(width: number, height: number): void;
  getCamera(): THREE.PerspectiveCamera;
  lookAt(target: THREE.Vector3): void;
  setPosition(position: THREE.Vector3): void;
  getPosition(): THREE.Vector3;
  getDirection(): THREE.Vector3;
}

--------------------------------------------------

--- Файл: src\rendering\mini-map.ts ---
import { SpaceObject } from "../entities/space-object";
import { Vector3D } from "../physics/vector";
import {
  CanvasName,
  Command,
  PlatformAdapter,
} from "../adapters/platform-adapter";

export class MiniMap {
  private container: HTMLCanvasElement | undefined;
  private context: CanvasRenderingContext2D;
  private width: number = 200;
  private height: number = 200;
  private centerX: number;
  private centerY: number;
  private zoomCount: number = 2;

  private zoomMap = new Map([
    [0, 0.00000000149],
    [1, 0.0000000008],
    [2, 0.00000000058],
    [3, 0.00000000038],
    [4, 0.000000000111],
    [5, 0.0000000000603],
    [6, 0.0000000000302],
    [7, 0.0000000000192],
  ]);

  constructor(private platformAdapter: PlatformAdapter) {
    this.container = platformAdapter.getCanvas(CanvasName.MINI_MAP);

    this.container.width = this.width;
    this.container.height = this.height;
    this.context = this.container.getContext("2d")!;

    this.centerX = this.width / 2;
    this.centerY = this.height / 2;

    this.container.style.position = "absolute";
    this.container.style.top = "20px";
    this.container.style.left = "20px";
    this.container.style.borderRadius = "8px";
    this.container.style.backgroundColor = "rgba(0, 0, 0, 0.7)";

    this.setupEvents(platformAdapter);
  }


  public init(): void {
    this.platformAdapter.appendToDom(this.container);
  }

  public render(objects: SpaceObject[]): void {
    this.clear();
    this.drawOrbits(objects);
    this.drawObjects(objects);
  }

  private setupEvents(platformAdapter: PlatformAdapter): void {
    platformAdapter.onPress(() => {
      this.zoomCount += 1;
    }, CanvasName.MINI_MAP);

    platformAdapter.onPressButton((value) => {
      if (value === Command.zoomMap) {
        this.zoomCount += 1;
      }
    });
  }

  private clear(): void {
    this.context.clearRect(0, 0, this.width, this.height);
  }

  private drawOrbits(objects: SpaceObject[]): void {
    const sunPos = objects.find((o) => o.name === "Sun")?.pos || new Vector3D();

    objects.forEach((obj) => {
      if (obj.name === "Sun" || obj.name === "Camera") return;

      const dx = obj.pos.x - sunPos.x;
      const dz = obj.pos.z - sunPos.z;
      const scale = this.zoomMap.get(this.zoomCount % 8) || 0;
      const radius = Math.sqrt(dx * dx + dz * dz) * scale;

      this.context.beginPath();
      this.context.ellipse(
        this.centerX,
        this.centerY,
        radius,
        radius,
        0,
        0,
        2 * Math.PI
      );
      this.context.strokeStyle = "rgba(255, 255, 255, 0.2)";
      this.context.lineWidth = 0.5;
      this.context.stroke();
    });
  }

  private drawObjects(objects: SpaceObject[]): void {
    const sunPos = objects.find((o) => o.name === "Sun")?.pos || new Vector3D();

    objects.forEach((obj) => {
      const dx = obj.pos.x - sunPos.x;
      const dz = obj.pos.z - sunPos.z;

      const scale = this.zoomMap.get(this.zoomCount % 8) || 0;
      const x = this.centerX + dx * scale;
      const y = this.centerY + dz * scale;

      const size = Math.max(2, obj.radius * scale);

      this.context.beginPath();
      this.context.arc(x, y, size, 0, 2 * Math.PI);
      this.context.fillStyle = obj.color;
      this.context.fill();

      this.context.font = "8px sans-serif";
      this.context.fillStyle = "white";
      this.context.textAlign = "center";
      this.context.fillText(obj.name, x, y + size + 10);
    });
  }
}

--------------------------------------------------

--- Файл: src\rendering\object-factory.ts ---
import * as THREE from "three";
import { SpaceObject } from "../entities/space-object";
import {
  ICameraController,
  IObjectFactory,
  ISceneManager,
  ITextureManager,
} from "./interfaces";
import { SIMULATION_CONFIG } from "../config/simulation-config";
import { PlatformAdapter } from "../adapters/platform-adapter";
import { SunShader } from "../ shaders/sun-shader";
import { GlowShader } from "../ shaders/glow-shader";
import { SolarSystem } from "../simulation/solar-system";

export class ObjectFactory implements IObjectFactory {
  private spaceObjectMaterials: Map<string, THREE.ShaderMaterial> = new Map();
  private spaceObjectMeshes: Map<string, THREE.Mesh> = new Map();
  private spaceObjectGroups: Map<string, THREE.Group> = new Map();
  private spaceObjectLabels: Map<string, THREE.Sprite> = new Map();
  private rotationAccumulators: Map<string, number> = new Map();

  constructor(
    private platformAdapter: PlatformAdapter,
    private textureManager: ITextureManager,
    private sceneManager: ISceneManager,
    private cameraController: ICameraController,
    private system: SolarSystem
  ) {}

  public init(): void {
    const background = this.createSpaceBackground();
    const spaceObjects = this.system.getSpaceObjects();

    this.sceneManager.getScene().add(background);

    spaceObjects.forEach((obj) => {
      if (obj.name === "Camera") return;

      let mesh: THREE.Mesh;

      if (obj.name === "Sun") {
        mesh = this.createSunMaterial(obj);
        const glowMesh = this.createGlowMaterial(obj, mesh);

        this.spaceObjectMeshes.set("SunGlow", glowMesh);
        this.sceneManager.getScene().add(mesh);
        this.sceneManager.getScene().add(glowMesh);
      } else {
        mesh = this.createSpaceObject(obj);

        this.sceneManager.getScene().add(mesh);
      }

      this.spaceObjectMeshes.set(obj.name, mesh);

      const labelSprite = this.createLabelSprite(obj.name);

      // Создаём Group для трансформаций (даже если вращение не нужно)
      const group = new THREE.Group();
      group.add(mesh); // Mesh становится дочерним
      this.sceneManager.getScene().add(group);
      this.spaceObjectGroups.set(obj.name, group); // Сохраняем Group

      if (labelSprite) {
        this.spaceObjectLabels.set(obj.name, labelSprite);
        this.sceneManager.getScene().add(labelSprite);
      }

      if (obj.rotationPeriod) {
        this.rotationAccumulators.set(obj.name, 0);
      }
    });
  }

  public render(deltaTime: number): void {
    const scaleDist = SIMULATION_CONFIG.SCALE_DIST;
    const spaceObjects = this.system.getSpaceObjects();

    spaceObjects.forEach((obj) => {
      if (obj.name === "Camera") {
        this.cameraController.setPosition(
          new THREE.Vector3(
            obj.pos.x * scaleDist,
            obj.pos.y * scaleDist,
            obj.pos.z * scaleDist
          )
        );

        return;
      }

      const mesh = this.spaceObjectMeshes.get(obj.name);
      const group = this.spaceObjectGroups.get(obj.name);
      const label = this.spaceObjectLabels.get(obj.name);

      if (!mesh || !group) return;

      // 1. Обновляем позицию Group (а не Mesh!)
      group.position.set(
        obj.pos.x * scaleDist,
        obj.pos.y * scaleDist,
        obj.pos.z * scaleDist
      );

      // 2. Применяем вращение к Group
      this.applyRotation(obj, group, mesh, deltaTime);

      // 3. Обновляем лейбл
      if (label) {
        this.updateLabelPosition(label, group, obj.radius, scaleDist);
      }

      // 4. Обновляем Glow для Солнца
      if (obj.name === "Sun") {
        this.updateSunGlow(mesh);
      }
    });

    this.updateSunShader();
  }

  private createSunMaterial(spaceObject: SpaceObject) {
    const sunMaterial = new THREE.ShaderMaterial({
      uniforms: SunShader.uniforms,
      vertexShader: SunShader.vertexShader,
      fragmentShader: SunShader.fragmentShader,
      transparent: false,
    });

    sunMaterial.uniforms.uTexture.value =
      this.textureManager.loadTexture("sun_color.jpg");
    sunMaterial.uniforms.uNormalMap.value =
      this.textureManager.loadTexture("sun_normal.jpg");
    sunMaterial.uniforms.uEmissiveMap.value =
      this.textureManager.loadTexture("sun_emissive.jpg");

    this.spaceObjectMaterials.set(spaceObject.name, sunMaterial);

    const sunGeometry = new THREE.SphereGeometry(
      this.calcRadiusPx(spaceObject.radius),
      32,
      32
    );

    const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);

    sunMesh.name = spaceObject.name;
    sunMesh.castShadow = false;
    sunMesh.receiveShadow = false;

    return sunMesh;
  }

  private createGlowMaterial(spaceObject: SpaceObject, mesh: THREE.Mesh) {
    const glowRadius = this.calcRadiusPx(spaceObject.radius) * 7;
    const glowGeometry = new THREE.PlaneGeometry(glowRadius, glowRadius);

    const glowMaterial = new THREE.ShaderMaterial({
      uniforms: GlowShader.uniforms,
      vertexShader: GlowShader.vertexShader,
      fragmentShader: GlowShader.fragmentShader,
      transparent: true,
      blending: THREE.NormalBlending,
      depthTest: true,
      depthWrite: false,
    });

    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);

    glowMesh.position.copy(mesh.position);
    glowMesh.castShadow = false;
    glowMesh.receiveShadow = false;

    return glowMesh;
  }

  private createSpaceObject(spaceObject: SpaceObject): THREE.Mesh {
    const material = this.getSpaceObjectMaterial(spaceObject);

    const geometry = new THREE.SphereGeometry(
      this.calcRadiusPx(spaceObject.radius),
      32,
      32
    );

    const mesh = new THREE.Mesh(geometry, material);
    mesh.name = spaceObject.name;
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    return mesh;
  }

  private createSpaceBackground(): THREE.Mesh {
    const spaceGeometry = new THREE.SphereGeometry(500000, 100, 100);
    const spaceTexture = this.textureManager.loadTexture("spacehigh.jpg");
    spaceTexture.anisotropy = 10;

    const spaceMaterial = new THREE.MeshBasicMaterial({
      map: spaceTexture,
      side: THREE.BackSide,
    });

    const background = new THREE.Mesh(spaceGeometry, spaceMaterial);
    background.scale.x = -1;
    background.scale.y = -1;
    background.scale.z = -1;
    background.rotation.x = -Math.PI * 0.37;
    background.rotation.y = -Math.PI * 0.88;
    background.rotation.z = Math.PI * 0.58;

    return background;
  }

  private createLabelSprite(text: string): THREE.Sprite | undefined {
    const canvas = this.platformAdapter.getCanvasWithoutAddToDom();

    if (!canvas) return;

    const context = canvas.getContext("2d")!;
    context.font = "24px Arial, sans-serif";
    context.textAlign = "center";

    context.fillStyle = "white";
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthTest: true,
    });

    return new THREE.Sprite(material);
  }

  private getSpaceObjectMaterial(spaceObject: SpaceObject) {
    if (spaceObject.texture) {
      const texture = this.textureManager.loadTexture(spaceObject.texture);

      return new THREE.MeshPhongMaterial({
        map: texture,
        bumpMap: texture,
        bumpScale: 0.05,
        color: 0xffffff,
        shininess: 30,
        specular: new THREE.Color(0x333333),
      });
    }

    return new THREE.MeshPhongMaterial({
      color: new THREE.Color(spaceObject.color),
      shininess: 5,
      specular: new THREE.Color(0x333333),
    });
  }

  private calcRadiusPx(radius: number) {
    return (
      radius *
      SIMULATION_CONFIG.SCALE_DIST *
      SIMULATION_CONFIG.OBJECTS_RADIUS_SCALE
    );
  }

  private applyRotation(
    obj: SpaceObject,
    group: THREE.Group,
    mesh: THREE.Mesh, // явно указываем тип
    deltaTime: number
  ): void {
    if (!obj.rotationPeriod) return;

    const periodSec = obj.rotationPeriod * 24 * 3600;
    const angularSpeed = (2 * Math.PI) / periodSec;
    const accumulator = this.rotationAccumulators.get(obj.name) || 0;

    const scaledDeltaTime =
      (deltaTime / 1000) * SIMULATION_CONFIG.SIMULATION_DT;
    const newAccumulator = accumulator + angularSpeed * scaledDeltaTime;
    this.rotationAccumulators.set(obj.name, newAccumulator);

    // Получаем equatorGroup (дочернюю группу для вращения)
    let equatorGroup = group.children.find(
      (child) => (child as any).userData?.isEquatorGroup
    ) as THREE.Group | undefined;

    if (!equatorGroup) {
      equatorGroup = new THREE.Group();
      equatorGroup.userData.isEquatorGroup = true;

      // Перемещаем mesh в equatorGroup
      mesh.parent?.remove(mesh);
      equatorGroup.add(mesh);
      group.add(equatorGroup);
    }

    // Наклоняем ось (через group)
    if (obj.axialTilt !== undefined) {
      group.rotation.x = THREE.MathUtils.degToRad(obj.axialTilt);
    } else {
      group.rotation.x = 0;
    }

    // Вращаем equatorGroup вокруг локальной y
    equatorGroup.rotation.y = newAccumulator;
  }

  private updateLabelPosition(
    label: THREE.Sprite,
    mesh: THREE.Group | THREE.Mesh,
    radius: number,
    scaleDist: number
  ): void {
    label.position.copy(mesh.position);
    label.position.y += radius * scaleDist * 1.3;

    const distance = this.cameraController
      .getCamera()
      .position.distanceTo(label.position);
    label.scale.setScalar(distance / SIMULATION_CONFIG.LABEL_SCALE_FATOR);
  }

  private updateSunGlow(mesh: THREE.Group | THREE.Mesh): void {
    const glowMesh = this.spaceObjectMeshes.get("SunGlow");
    if (glowMesh) {
      glowMesh.position.copy(mesh.position);
      glowMesh.lookAt(this.cameraController.getCamera().position);
    }
  }

  private updateSunShader(): void {
    const sunMaterial = this.spaceObjectMaterials.get("Sun");
    if (sunMaterial) {
      sunMaterial.uniforms.uTime.value += 0.001;
    }
  }
}

--------------------------------------------------

--- Файл: src\rendering\renderer-core.ts ---
import * as THREE from "three";
import { CanvasName, PlatformAdapter } from "../adapters/platform-adapter";
import { ISceneManager } from "./interfaces";
import { ICameraController } from "./interfaces";
import { IObjectFactory } from "./interfaces";
import { MiniMap } from "./mini-map";
import { SolarSystem } from "../simulation/solar-system";
import { FPS } from "./fps";

export class RendererCore {
  private renderer: THREE.WebGLRenderer;

  constructor(
    private platformAdapter: PlatformAdapter,
    private sceneManager: ISceneManager,
    private cameraController: ICameraController,
    private objectFactory: IObjectFactory,
    private miniMap: MiniMap,
    private system: SolarSystem,
    private fps: FPS,
  ) {

    this.renderer = new THREE.WebGLRenderer({
      canvas: this.platformAdapter.getCanvas(CanvasName.MAIN_SCENE),
      antialias: true,
    });

    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Мягкие тени
    // Альтернативы:
    // THREE.PCFShadowMap (чётче)
    // THREE.BasicShadowMap (быстрее, грубее)
  }

  public init(): void {
    this.renderer.setPixelRatio(this.platformAdapter.getPixelRatio());

    this.platformAdapter.onResize(() => {
      const width = this.platformAdapter.getWidth();
      const height = this.platformAdapter.getHeight();
      
      this.renderer.setSize(width, height);
      this.cameraController.resize(width, height);
    });

    this.renderer.setSize(
      this.platformAdapter.getWidth(),
      this.platformAdapter.getHeight()
    );

    this.objectFactory.init();
    this.miniMap.init();
    this.fps.init();
  }

  public render(deltaTime: number): void {
    this.objectFactory.render(deltaTime);
    this.miniMap.render(this.system.getSpaceObjects());
    this.fps.render(deltaTime)

    this.renderer.render(
      this.sceneManager.getScene(),
      this.cameraController.getCamera()
    );
  }
}

--------------------------------------------------

--- Файл: src\rendering\scene-manager.ts ---
import * as THREE from "three";
import { ISceneManager } from "./interfaces";
import { TextureManager } from "./texture-manager";

export class SceneManager implements ISceneManager {
  private scene: THREE.Scene;

  constructor() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000000);

    this.setupLighting();
  }

  getScene(): THREE.Scene {
    return this.scene;
  }

  setupLighting(): void {
    const pointLight = new THREE.PointLight(0xffffff, 1.5);

    pointLight.position.set(0, 0, 0);
    pointLight.shadow.mapSize.width = 2048;
    pointLight.shadow.mapSize.height = 2048;
    pointLight.shadow.camera.near = 1;
    pointLight.shadow.camera.far = 500000;
    pointLight.shadow.bias = 0.0001;
    pointLight.shadow.radius = 1;
    this.scene.add(pointLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);

    this.scene.add(ambientLight);
  }
}

--------------------------------------------------

--- Файл: src\rendering\texture-manager.ts ---
import * as THREE from "three";
import { ITextureManager } from "./interfaces";

export class TextureManager implements ITextureManager {
  private textureLoader: THREE.TextureLoader;
  private cache: Map<string, THREE.Texture> = new Map();

  constructor() {
    this.textureLoader = new THREE.TextureLoader();
  }

  loadTexture(path: string): THREE.Texture {
    if (this.cache.has(path)) {
      return this.cache.get(path)!;
    }

    const texture = this.textureLoader.load(
      `src/textures/${path}`,
      () => console.log(`Текстура загружена: ${path}`),
      undefined,
      (error) => console.error(`Ошибка загрузки текстуры: ${path}`, error)
    );

    texture.anisotropy = 7;
    this.cache.set(path, texture);

    return texture;
  }
}

--------------------------------------------------

--- Файл: src\simulation\solar-system.ts ---
import { SpaceObject } from "../entities/space-object";
import { spaceObjects } from "../config/space-objects";
import { SIMULATION_CONFIG } from "../config/simulation-config";
import { Vector3D } from "../physics/vector";
import { CelestialBody } from "../entities/celestial-body";

export class SolarSystem {
  private spaceObjects: SpaceObject[] = [];
  private dt: number;

  constructor(dt: number = SIMULATION_CONFIG.DEFAULT_DT) {
    this.dt = dt;
    this.initSpaceObjects();
  }

  private initSpaceObjects(): void {
    this.spaceObjects = this.createSpaceObjectsFromCelestialBody(spaceObjects);
  }

  private createSpaceObjectsFromCelestialBody(
    body: CelestialBody,
    parent?: SpaceObject
  ): SpaceObject[] {
    const spaceObjects: SpaceObject[] = [];

    const spaceObject = new SpaceObject(
      body.name,
      body.mass ?? body.totalMass,
      body.pos.clone(),
      body.vel.clone(),
      parent ? body.pos.clone() : new Vector3D(),
      parent ? body.vel.clone() : new Vector3D(),
      body.color ?? null,
      body.radius,
      body.texture ?? "",
      body.rotationPeriod ?? 0,
      body.axialTilt ?? 0,
      body.totalMass,
      body.children
    );

    if (parent) spaceObject.parent = parent;
    spaceObjects.push(spaceObject);

    if (body.children && body.children.length > 0) {
      for (const child of body.children) {
        const childObjects = this.createSpaceObjectsFromCelestialBody(
          child,
          spaceObject
        );

        spaceObjects.push(...childObjects);
      }
    }

    return spaceObjects;
  }

  getSpaceObjects(): SpaceObject[] {
    return this.spaceObjects;
  }

  step(dt: number = this.dt): void {
    for (const spaceObject of this.spaceObjects) {
      if (!spaceObject.isSatellite()) {
        spaceObject.update(dt, this.spaceObjects);
      }
    }

    for (const spaceObject of this.spaceObjects) {
      if (spaceObject.children) {
        spaceObject.updateChildrenPositions(dt, spaceObject, this.spaceObjects);
      }
    }
  }

  public applyCameraVelocityImpulse(dx: number, dy: number, dz: number): void {
    const camera = this.spaceObjects.find((obj) => obj.name === "Camera");

    if (camera) {
      camera.vel = camera.vel.add(new Vector3D(dx, dy, dz));
    } else {
      console.warn("Камера не найдена в системе!");
    }
  }
}

--------------------------------------------------

============================================================
CNHERNEHF ДИРЕКТОРИИ:
============================================================
 shaders/
  glow-shader.ts
  sun-shader.ts
adapters/
  browser-adapter.ts
  platform-adapter.ts
config/
  config-api.ts
  simulation-config.ts
  space-objects.ts
entities/
  celestial-body.ts
  interface.ts
  space-object.ts
main.ts
physics/
  gravity.ts
  vector.ts
rendering/
  camera-controller.ts
  fps.ts
  interfaces.ts
  mini-map.ts
  object-factory.ts
  renderer-core.ts
  scene-manager.ts
  texture-manager.ts
simulation/
  solar-system.ts
textures/
  corona.png
  earthhigh-min.jpg
  earthlow-min.jpg
  earthmedium-min.jpg
  jupiterhigh-min.jpg
  jupiterlow-min.jpg
  jupitermedium-min.jpg
  marshigh-min.jpg
  marslow-min.jpg
  marsmedium-min.jpg
  mercuryhigh-min.jpg
  mercurylow-min.jpg
  mercurymedium-min.jpg
  moonhigh-min.jpg
  moonlow-min.jpg
  moonmedium-min.jpg
  neptunehigh-min.jpg
  neptunelow-min.jpg
  neptunemedium-min.jpg
  plutohigh-min.jpg
  plutolow-min.jpg
  plutomedium-min.jpg
  saturnhigh-min.jpg
  saturnlow-min.jpg
  saturnmedium-min.jpg
  saturn_ringhigh.png
  saturn_ringlow.png
  saturn_ringmedium.png
  sol.png
  spacehigh.jpg
  spacelow.jpg
  spacemedium.jpg
  sun_color.jpg
  sun_emissive.jpg
  sun_normal.jpg
  uranushigh-min.jpg
  uranuslow-min.jpg
  uranusmedium-min.jpg
  uranus_ringhigh.png
  uranus_ringlow.png
  uranus_ringmedium.png
  venushigh-min.jpg
  venuslow-min.jpg
  venusmedium-min.jpg